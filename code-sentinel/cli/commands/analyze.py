import click
import time
import hashlib
import json
from pathlib import Path
from typing import Optional, List, Dict
from dataclasses import dataclass, asdict

from core.query.query_parser import DataflowNode, PatternNode
from core.query.query_executor import QueryExecutor
from core.extractors.python_extractor import PythonExtractor

@dataclass
class AnalysisResult:
    """Structured result from code analysis."""
    file: str
    type: str
    line: int
    snippet: str
    severity: str = "medium"
    fix_suggestion: Optional[str] = None

class FileCache:
    """Simple cache for file analysis results."""
    def __init__(self, cache_dir: Path):
        self.cache_dir = cache_dir
        self.cache_dir.mkdir(parents=True, exist_ok=True)

    def get_hash(self, file_path: Path) -> str:
        """Get hash of file contents."""
        return hashlib.sha256(file_path.read_bytes()).hexdigest()

    def get_cached_results(self, file_path: Path) -> Optional[List[Dict]]:
        """Get cached results for a file if valid."""
        cache_file = self.cache_dir / f"{file_path.name}.{self.get_hash(file_path)}.json"
        if cache_file.exists():
            return json.loads(cache_file.read_text())
        return None

    def cache_results(self, file_path: Path, results: List[Dict]):
        """Cache results for a file."""
        cache_file = self.cache_dir / f"{file_path.name}.{self.get_hash(file_path)}.json"
        cache_file.write_text(json.dumps(results))

def get_fix_suggestion(issue_type: str, snippet: str) -> str:
    """Generate a fix suggestion based on the issue type."""
    suggestions = {
        'command_injection': 'Use subprocess.run() with shell=False and proper argument splitting',
        'shell_injection': 'Remove shell=True and use proper argument lists',
        'eval_usage': 'Replace eval() with safer alternatives like ast.literal_eval() or proper parsing',
        'file_access': 'Validate file paths and use with statement for file operations',
        'unvalidated_input': 'Add input validation before processing user input',
        'resource_leak': 'Use "with" statement for proper resource management',
        'bare_except': 'Catch specific exceptions instead of using bare except',
        'sleep_usage': 'Consider using async/await or event-based approaches instead of sleep',
    }
    return suggestions.get(issue_type, 'Review and fix according to security best practices')

@click.command()
@click.argument('path', type=click.Path(exists=True))
@click.option('--claude-mode', is_flag=True, help='Enable specific checks for Claude-generated code')
@click.option('--timeout', type=int, default=30, help='Analysis timeout in seconds')
@click.option('--format', type=click.Choice(['text', 'json', 'brief']), default='text', help='Output format')
@click.option('--cache/--no-cache', default=True, help='Enable/disable result caching')
@click.option('--fix-suggestions/--no-fix-suggestions', default=True, help='Include fix suggestions in output')
def analyze(path: str, claude_mode: bool, timeout: int, format: str, cache: bool, fix_suggestions: bool):
    """Analyze code for potential issues.

    If --claude-mode is enabled, applies specific checks for code generated by Claude
    during Computer Use Demo sessions.
    """
    start_time = time.time()

    # Initialize components
    executor = QueryExecutor([PythonExtractor()], config={'timeout_seconds': timeout})
    target_path = Path(path).expanduser().resolve()  # Handle ~ in paths
    cache_handler = FileCache(Path.home() / '.code-sentinel' / 'cache') if cache else None

    # Collect all Python files
    python_files = []
    if target_path.is_file():
        python_files = [target_path] if target_path.suffix == '.py' else []
    else:
        python_files = list(target_path.rglob('*.py'))

    if not python_files:
        click.echo("No Python files found to analyze.")
        return

    # Define basic security checks
    security_checks = [
        ('command_injection', DataflowNode(source='input', sink='os.system'), 'high'),
        ('shell_injection', PatternNode(pattern='subprocess\\..*shell=True'), 'high'),
        ('eval_usage', PatternNode(pattern='eval\\('), 'high'),
        ('file_access', DataflowNode(source='input', sink='open'), 'medium'),
    ]

    # Add Claude-specific checks if enabled
    if claude_mode:
        claude_checks = [
            ('unvalidated_input', PatternNode(pattern='input\\(\\).*\\w+\\('), 'medium'),
            ('resource_leak', PatternNode(pattern='open\\(.*\\)(?!.*with)'), 'medium'),
            ('bare_except', PatternNode(pattern='except:'), 'low'),
            ('sleep_usage', PatternNode(pattern='time\\.sleep'), 'low'),
        ]
        security_checks.extend(claude_checks)

    # Run analysis
    issues = []
    for file_path in python_files:
        rel_path = file_path.relative_to(target_path)
        click.echo(f"Analyzing {rel_path}...")

        # Check cache first
        if cache_handler:
            cached_results = cache_handler.get_cached_results(file_path)
            if cached_results:
                issues.extend(cached_results)
                continue

        file_issues = []
        for check_name, query, severity in security_checks:
            try:
                results = list(executor.execute(query, [file_path]))
                for result in results:
                    issue = AnalysisResult(
                        file=str(rel_path),
                        type=check_name,
                        line=result.line_number,
                        snippet=result.snippet.strip(),
                        severity=severity,
                        fix_suggestion=get_fix_suggestion(check_name, result.snippet.strip()) if fix_suggestions else None
                    )
                    file_issues.append(asdict(issue))
            except Exception as e:
                click.echo(f"Error running {check_name} check: {e}", err=True)

        if cache_handler and file_issues:
            cache_handler.cache_results(file_path, file_issues)
        issues.extend(file_issues)

    # Output results
    stats = {
        'files_analyzed': len(python_files),
        'issues_found': len(issues),
        'analysis_time': time.time() - start_time,
        'severity_counts': {
            'high': len([i for i in issues if i['severity'] == 'high']),
            'medium': len([i for i in issues if i['severity'] == 'medium']),
            'low': len([i for i in issues if i['severity'] == 'low']),
        }
    }

    if format == 'json':
        click.echo(json.dumps({
            'issues': issues,
            'stats': stats
        }, indent=2))
    elif format == 'brief':
        # Brief format for LLM consumption
        if issues:
            click.echo(f"\nFound {len(issues)} issues:")
            for severity in ['high', 'medium', 'low']:
                sev_issues = [i for i in issues if i['severity'] == severity]
                if sev_issues:
                    click.echo(f"\n{severity.upper()} severity issues:")
                    for issue in sev_issues:
                        click.echo(f"- {issue['type']} in {issue['file']} line {issue['line']}")
        else:
            click.echo("\nNo issues found.")
        click.echo(f"\nAnalyzed {stats['files_analyzed']} files in {stats['analysis_time']:.2f} seconds.")
    else:
        if issues:
            click.echo("\nIssues found:")
            for severity in ['high', 'medium', 'low']:
                sev_issues = [i for i in issues if i['severity'] == severity]
                if sev_issues:
                    click.echo(f"\n{severity.upper()} severity issues:")
                    for issue in sev_issues:
                        click.echo(f"\n{issue['file']}:{issue['line']} - {issue['type']}")
                        click.echo(f"  {issue['snippet']}")
                        if fix_suggestions and issue['fix_suggestion']:
                            click.echo(f"  Suggestion: {issue['fix_suggestion']}")
        else:
            click.echo("\nNo issues found.")

        click.echo(f"\nAnalysis Summary:")
        click.echo(f"Files analyzed: {stats['files_analyzed']}")
        click.echo(f"Total issues: {stats['issues_found']}")
        click.echo(f"Severity breakdown:")
        click.echo(f"  High: {stats['severity_counts']['high']}")
        click.echo(f"  Medium: {stats['severity_counts']['medium']}")
        click.echo(f"  Low: {stats['severity_counts']['low']}")
        click.echo(f"Analysis time: {stats['analysis_time']:.2f} seconds")
